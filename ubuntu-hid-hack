#!/bin/bash

set -e
grep -q 'Ubuntu 16.04' /etc/issue
test "$(id -u)" = 0
test -x /usr/bin/python3

if [[ ! -f 99-expose-all-hidraw.rules ]]; then
  #
  # When you plug in a Yubico U2F security key, a corresponding hidraw device
  # node is created, and it is usually named named like "/dev/hidraw0".  When
  # you use /dev/uhid ABI to create a new HID device, same thing happens.  I
  # don't know exactly how Google Chrome interacts with U2F devices yet, but I
  # do know that if I make the hidraw device node corresponding to the virtual
  # HID created by v2f.py globally-read-and-writable, Google Chrome will be
  # able to interact with it too.
  #
  # Sadly I don't know a good way to automatically `chmod 0666 /dev/hidrawN`
  # whenever I use v2f.py to create a new U2F HID device.
  #
  # Therefore, here is a quick hack which makes all hidraw device nodes
  # globally-read-and-writable.  For some obvious reason, it is less secure.
  # Yet it works.
  #
  echo 'KERNEL=="hidraw*", SUBSYSTEM=="hidraw", MODE="0666"' > /etc/udev/rules.d/99-expose-all-hidraw.rules
  udevadm trigger
fi

printf %s '#!/usr/bin/python3
import os
import sys
import time
try:
  fd = os.open("/dev/uhid", os.O_RDWR)
  data = bytes.fromhex("0b"+"0"*518+"22"+"0"*38+"06d0f10901a1010920150026ff007508954081020921150026ff00750895409102c0")
  assert 314 == os.write(fd, data)
  time.sleep(.5)
  os.close(fd)
  time.sleep(.5)
  os.chmod("/dev/uhid", 0o666)
except:
  sys.exit(1)
else:
  sys.exit(0)
' > /usr/local/bin/ensure-uhid

chmod +x /usr/local/bin/ensure-uhid

mv /etc/rc.local /etc/rc.local.bak."$(date +%Y%m%d.%H%M%S)"

/usr/local/bin/ensure-uhid

# TODO change this uhid hack into a single systemd service without rc.local
echo '/usr/local/bin/ensure-uhid; exit 0' > /etc/rc.local
chmod +x /etc/rc.local
systemctl enable rc-local.service
